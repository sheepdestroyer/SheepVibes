============================= test session starts ==============================
platform linux -- Python 3.14.2, pytest-9.0.2, pluggy-1.6.0
rootdir: /home/sheepdestroyer/LAB/SheepVibes
plugins: mock-3.15.1, env-1.2.0, base-url-2.1.0, playwright-0.7.2
collected 71 items

tests/e2e/test_infinite_scroll.py s                                      [  1%]
tests/unit/test_progress.py s                                            [  2%]
tests/test_multiuser.py EEE                                              [  7%]
tests/unit/test_app.py EEEEEEE                                           [ 16%]
tests/unit/test_cache_utils.py EEEEEEEEEE                                [ 30%]
tests/unit/test_feed.py ................                                 [ 53%]
tests/unit/test_feed_config.py ......                                    [ 61%]
tests/unit/test_feed_eviction.py EEEEE                                   [ 69%]
tests/unit/test_opml_import.py EEEEEEEEE                                 [ 81%]
tests/unit/test_security_headers.py ...                                  [ 85%]
tests/unit/test_tabs_optimization.py EEE                                 [ 90%]
tests/unit/test_xxe_prevention.py .......                                [100%]

==================================== ERRORS ====================================
__________________ ERROR at setup of test_register_and_login ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_multiuser_isolation __________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_____________________ ERROR at setup of test_admin_access ______________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
____________________ ERROR at setup of test_get_tabs_empty _____________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_get_tabs_with_data ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_create_tab_success ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_rename_tab_success ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_delete_tab_success ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
___________________ ERROR at setup of test_add_feed_success ____________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
________________ ERROR at setup of test_mark_item_read_success _________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_get_version_default __________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
____________ ERROR at setup of test_get_version_falsy_cached_value _____________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_get_version_cached ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_make_tabs_cache_key __________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_ ERROR at setup of test_make_tab_feeds_cache_key[default_versions_no_query_params] _

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_ ERROR at setup of test_make_tab_feeds_cache_key[custom_versions_no_query_params] _

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
______ ERROR at setup of test_make_tab_feeds_cache_key[with_query_params] ______

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_ ERROR at setup of test_make_tab_feeds_cache_key[multiple_values_for_query_param] _

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_________________ ERROR at setup of test_invalidate_tabs_cache _________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
______________ ERROR at setup of test_invalidate_tab_feeds_cache _______________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture(autouse=True)
    def app_context():
        """Provide an app context and clear the cache for each test."""
        with app.app_context():
>           cache.clear()

tests/unit/test_cache_utils.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_________________ ERROR at setup of test_eviction_under_limit __________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
___________________ ERROR at setup of test_eviction_at_limit ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
____________ ERROR at setup of test_eviction_over_limit_within_cap _____________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
___________ ERROR at setup of test_eviction_over_limit_exceeding_cap ___________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
________________ ERROR at setup of test_eviction_null_handling _________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
________________________ ERROR at setup of test_import _________________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________________ ERROR at setup of test_import_nested_opml ___________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
________ ERROR at setup of test_opml_import_skips_skipped_folder_types _________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________ ERROR at setup of test_opml_import_skips_invalid_feed_urls __________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_________ ERROR at setup of test_opml_import_skips_duplicate_feed_urls _________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
__________ ERROR at setup of test_opml_import_folder_only_no_outlines __________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
____________ ERROR at setup of test_opml_import_no_outline_elements ____________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
________ ERROR at setup of test_opml_import_anonymous_folder_with_feeds ________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_________________ ERROR at setup of test_import_malformed_opml _________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_____________ ERROR at setup of test_get_tabs_query_count_constant _____________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
_______________ ERROR at setup of test_tab_to_dict_optimization ________________

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
___ ERROR at setup of test_tab_to_dict_db_lookup_uses_single_aggregate_query ___

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
>               sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )

.venv/lib64/python3.14/site-packages/redis/connection.py:855: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/redis/retry.py:116: in call_with_retry
    return do()
           ^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:856: in <lambda>
    lambda: self._connect(), lambda error: self.disconnect(error)
            ^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:1306: in _connect
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>

    def _connect(self):
        "Create a TCP socket connection"
        # we want to mimic what socket.create_connection does to support
        # ipv4/ipv6, but we want to set options prior to calling
        # socket.connect()
        err = None
    
        for res in socket.getaddrinfo(
            self.host, self.port, self.socket_type, socket.SOCK_STREAM
        ):
            family, socktype, proto, canonname, socket_address = res
            sock = None
            try:
                sock = socket.socket(family, socktype, proto)
                # TCP_NODELAY
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
                # TCP_KEEPALIVE
                if self.socket_keepalive:
                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                    for k, v in self.socket_keepalive_options.items():
                        sock.setsockopt(socket.IPPROTO_TCP, k, v)
    
                # set the socket_connect_timeout before we connect
                sock.settimeout(self.socket_connect_timeout)
    
                # connect
>               sock.connect(socket_address)
E               ConnectionRefusedError: [Errno 111] Connection refused

.venv/lib64/python3.14/site-packages/redis/connection.py:1290: ConnectionRefusedError

During handling of the above exception, another exception occurred:

    @pytest.fixture
    def client():
        app.config["TESTING"] = True
        app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
        app.config["SECRET_KEY"] = "test-secret"
        app.config["WTF_CSRF_ENABLED"] = False
        app.config["CACHE_TYPE"] = "SimpleCache"
    
        from backend.app import cache
    
        with app.test_client() as client, app.app_context():
            db.create_all()
>           cache.clear()

tests/conftest.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib64/python3.14/site-packages/flask_caching/__init__.py:219: in clear
    return self.cache.clear()
           ^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/cachelib/redis.py:148: in clear
    keys = self._read_client.keys(self._get_prefix() + "*")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/commands/core.py:2043: in keys
    return self.execute_command("KEYS", pattern, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:657: in execute_command
    return self._execute_command(*args, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/client.py:663: in _execute_command
    conn = self.connection or pool.get_connection()
                              ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/utils.py:196: in wrapper
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
.venv/lib64/python3.14/site-packages/redis/connection.py:2603: in get_connection
    connection.connect()
.venv/lib64/python3.14/site-packages/redis/connection.py:846: in connect
    self.connect_check_health(check_health=True)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <redis.connection.Connection(host=localhost,port=6379,db=0)>
check_health = True, retry_socket_connect = True

    def connect_check_health(
        self, check_health: bool = True, retry_socket_connect: bool = True
    ):
        if self._sock:
            return
        try:
            if retry_socket_connect:
                sock = self.retry.call_with_retry(
                    lambda: self._connect(), lambda error: self.disconnect(error)
                )
            else:
                sock = self._connect()
        except socket.timeout:
            raise TimeoutError("Timeout connecting to server")
        except OSError as e:
>           raise ConnectionError(self._error_message(e))
E           redis.exceptions.ConnectionError: Error 111 connecting to localhost:6379. Connection refused.

.venv/lib64/python3.14/site-packages/redis/connection.py:863: ConnectionError
=============================== warnings summary ===============================
tests/unit/test_feed.py: 10 warnings
  /home/sheepdestroyer/LAB/SheepVibes/tests/unit/test_feed.py:51: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    if not User.query.get(1):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
ERROR tests/test_multiuser.py::test_register_and_login - redis.exceptions.Con...
ERROR tests/test_multiuser.py::test_multiuser_isolation - redis.exceptions.Co...
ERROR tests/test_multiuser.py::test_admin_access - redis.exceptions.Connectio...
ERROR tests/unit/test_app.py::test_get_tabs_empty - redis.exceptions.Connecti...
ERROR tests/unit/test_app.py::test_get_tabs_with_data - redis.exceptions.Conn...
ERROR tests/unit/test_app.py::test_create_tab_success - redis.exceptions.Conn...
ERROR tests/unit/test_app.py::test_rename_tab_success - redis.exceptions.Conn...
ERROR tests/unit/test_app.py::test_delete_tab_success - redis.exceptions.Conn...
ERROR tests/unit/test_app.py::test_add_feed_success - redis.exceptions.Connec...
ERROR tests/unit/test_app.py::test_mark_item_read_success - redis.exceptions....
ERROR tests/unit/test_cache_utils.py::test_get_version_default - redis.except...
ERROR tests/unit/test_cache_utils.py::test_get_version_falsy_cached_value - r...
ERROR tests/unit/test_cache_utils.py::test_get_version_cached - redis.excepti...
ERROR tests/unit/test_cache_utils.py::test_make_tabs_cache_key - redis.except...
ERROR tests/unit/test_cache_utils.py::test_make_tab_feeds_cache_key[default_versions_no_query_params]
ERROR tests/unit/test_cache_utils.py::test_make_tab_feeds_cache_key[custom_versions_no_query_params]
ERROR tests/unit/test_cache_utils.py::test_make_tab_feeds_cache_key[with_query_params]
ERROR tests/unit/test_cache_utils.py::test_make_tab_feeds_cache_key[multiple_values_for_query_param]
ERROR tests/unit/test_cache_utils.py::test_invalidate_tabs_cache - redis.exce...
ERROR tests/unit/test_cache_utils.py::test_invalidate_tab_feeds_cache - redis...
ERROR tests/unit/test_feed_eviction.py::test_eviction_under_limit - redis.exc...
ERROR tests/unit/test_feed_eviction.py::test_eviction_at_limit - redis.except...
ERROR tests/unit/test_feed_eviction.py::test_eviction_over_limit_within_cap
ERROR tests/unit/test_feed_eviction.py::test_eviction_over_limit_exceeding_cap
ERROR tests/unit/test_feed_eviction.py::test_eviction_null_handling - redis.e...
ERROR tests/unit/test_opml_import.py::test_import - redis.exceptions.Connecti...
ERROR tests/unit/test_opml_import.py::test_import_nested_opml - redis.excepti...
ERROR tests/unit/test_opml_import.py::test_opml_import_skips_skipped_folder_types
ERROR tests/unit/test_opml_import.py::test_opml_import_skips_invalid_feed_urls
ERROR tests/unit/test_opml_import.py::test_opml_import_skips_duplicate_feed_urls
ERROR tests/unit/test_opml_import.py::test_opml_import_folder_only_no_outlines
ERROR tests/unit/test_opml_import.py::test_opml_import_no_outline_elements - ...
ERROR tests/unit/test_opml_import.py::test_opml_import_anonymous_folder_with_feeds
ERROR tests/unit/test_opml_import.py::test_import_malformed_opml - redis.exce...
ERROR tests/unit/test_tabs_optimization.py::test_get_tabs_query_count_constant
ERROR tests/unit/test_tabs_optimization.py::test_tab_to_dict_optimization - r...
ERROR tests/unit/test_tabs_optimization.py::test_tab_to_dict_db_lookup_uses_single_aggregate_query
============ 32 passed, 2 skipped, 10 warnings, 37 errors in 6.43s =============
